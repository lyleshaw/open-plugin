// Code generated by hertz generator.

package service

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/bytedance/gopkg/util/logger"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/hertz-contrib/sse"
	"github.com/lyleshaw/open-plugin/biz/dal/mysql"
	"github.com/lyleshaw/open-plugin/biz/model/orm_gen"
	"github.com/lyleshaw/open-plugin/biz/model/service"
	"github.com/lyleshaw/open-plugin/pkg/constants"
	"github.com/lyleshaw/open-plugin/pkg/llm_anthropic"
	"github.com/lyleshaw/open-plugin/pkg/utils"
	"github.com/madebywelch/anthropic-go/pkg/anthropic"
	"github.com/sashabaranov/go-openai"
	"github.com/valyala/fasttemplate"
	"net/http"
	"os"
)

// GetChat .
// @router /api/chat [GET]
func GetChat(ctx context.Context, c *app.RequestContext) {
	var err error
	var req service.GetChatReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(400, err.Error())
		return
	}

	chat, err := mysql.GetChatByConversationID(ctx, req.ConversationID)

	resp := service.ChatResp{
		Code:    0,
		Message: "Success",
		Data: &service.Chat{
			ChatID:         chat.ChatID,
			ConversationID: chat.ConversationID,
			PluginNames:    nil,
			ChatContent:    chat.ChatContent,
			ChatModel:      chat.ChatModel,
			UserID:         chat.UserID,
			IsDeleted:      chat.IsDeleted,
			CreatedAt:      chat.CreatedAt.Format(constants.TimeFormat),
			UpdatedAt:      chat.UpdatedAt.Format(constants.TimeFormat),
		},
	}

	c.JSON(200, resp)
}

// PostChat .
// @router /api/chat [POST]
func PostChat(ctx context.Context, c *app.RequestContext) {
	var err error
	var req service.PostChatReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(400, err.Error())
		return
	}

	logger.Infof("req: %+v\n", req)

	pluginNamesString, err := json.Marshal(req.PluginNames)
	if err != nil {
		c.String(400, err.Error())
		return
	}

	chatModelString, err := json.Marshal(req.ChatModel)
	if err != nil {
		c.String(400, err.Error())
		return
	}

	// Get plugins from plugin names
	var plugins []*constants.Plugin
	var plugin constants.Plugin
	pluginModels, err := mysql.BatchGetPlugins(ctx, req.PluginNames)
	if err != nil {
		c.String(400, err.Error())
		return
	}
	for _, pluginModel := range pluginModels {
		err = json.Unmarshal([]byte(pluginModel.PluginConfig), &plugin)
		plugins = append(plugins, &plugin)
	}

	// LLM client config
	client, _ := llm_anthropic.GetClaudeClient()
	config := openai.DefaultConfig(os.Getenv("API_KEY"))
	config.BaseURL = os.Getenv("BASE_URL")
	clientOpenai := openai.NewClientWithConfig(config)

	// SSE stream start
	c.SetStatusCode(http.StatusOK)
	s := sse.NewStream(c)

	completion := ""
	var callback anthropic.StreamCallback = func(resp *anthropic.CompletionResponse) error {
		logger.Infof("resp.Completion: %+v\n", resp.Completion)
		respString, _ := json.Marshal(resp)
		completion = resp.Completion
		chatCompletionEvent := &sse.Event{
			Event: "completion",
			Data:  respString,
		}
		err = s.Publish(chatCompletionEvent)
		return nil
	}

	for true {
		// Detect plugin
		selectedPlugin, err := utils.SelectPluginsByOpenAI(ctx, clientOpenai, req.Prompt, plugins)
		if err != nil {
			logger.Errorf("err in SelectPluginsByOpenAI: %+v\n", err)
			selectedPlugin = "None"
		}
		existPlugin := false
		for _, prePlugin := range plugins {
			if selectedPlugin == prePlugin.Name {
				plugin = *prePlugin
				existPlugin = true
				logger.Infof("selectedPlugin: %+v\n", selectedPlugin)
				pluginSelectedEvent := &sse.Event{
					Event: "plugin_selected",
					Data:  []byte(selectedPlugin),
				}
				err = s.Publish(pluginSelectedEvent)
				break
			}
		}

		if existPlugin {
			// Detect params
			params, err := utils.DetectParamsByOpenAI(ctx, clientOpenai, req.Prompt, &plugin)
			if err != nil {
				logger.Errorf("err in DetectParamsByOpenAI: %+v\n", err)
				return
			}
			logger.Infof("params: %+v\n", params)
			paramsString, _ := json.Marshal(params)
			pluginRequestedEvent := &sse.Event{
				Event: "plugin_requested",
				Data:  paramsString,
			}
			err = s.Publish(pluginRequestedEvent)

			// Call plugin api
			apiResponse, err := utils.APIToResponse(plugin.BaseURL, params)
			if err != nil {
				logger.Errorf("err in APIToResponse: %+v\n", err)
				return
			}
			logger.Infof("apiResponse: %+v\n", apiResponse)
			pluginResponsedEvent := &sse.Event{
				Event: "plugin_responsed",
				Data:  []byte(apiResponse),
			}
			err = s.Publish(pluginResponsedEvent)

			// Mix response
			t := fasttemplate.New(constants.MixResponse, "{{", "}}")
			mixedPrompt := t.ExecuteString(map[string]interface{}{
				"pluginName":  plugin.Name,
				"apiResponse": apiResponse,
				"userPrompt":  req.Prompt,
			})
			logger.Infof("mixedPrompt: %+v\n", mixedPrompt)

			// Call anthropic
			err = llm_anthropic.CompletionWithSessionWithStreamByClaude(client, req.ConversationID, mixedPrompt, callback)
			llm_anthropic.AddMessageToClaude(req.ConversationID,
				fmt.Sprintf("\n\nHuman: %s\nHere are the plugin response:\n%s\n\nAssistant: %s",
					req.Prompt, mixedPrompt, completion))

			if err != nil {
				logger.Errorf("err in CompletionWithSessionWithStreamByClaude: %+v\n", err)
				return
			}
		} else {
			err = llm_anthropic.CompletionWithSessionWithStreamByClaude(client, req.ConversationID, req.Prompt, callback)
			llm_anthropic.AddMessageToClaude(req.ConversationID,
				fmt.Sprintf("\n\nHuman: %s\n\nAssistant: %s", req.Prompt, completion))
			if err != nil {
				logger.Errorf("err in CompletionWithSessionWithStreamByClaude: %+v\n", err)
				return
			}
		}
		break
	}

	chat, err := mysql.GetChatByConversationID(ctx, req.ConversationID)
	if chat != nil {
		_, err = mysql.UpdateChatContent(ctx, int(chat.ChatID), llm_anthropic.MessageQueueClaude[req.ConversationID])
		if err != nil {
			logger.Errorf("err in UpdateChatContent: %+v\n", err)
			return
		}
		return
	}

	chat = &orm_gen.Chat{
		ConversationID: req.ConversationID,
		PluginNames:    string(pluginNamesString),
		ChatContent:    llm_anthropic.MessageQueueClaude[req.ConversationID],
		ChatModel:      string(chatModelString),
		UserID:         0,
	}

	_, err = mysql.CreateChat(ctx, chat)
	if err != nil {
		logger.Errorf("err in CreateChat: %+v\n", err)
		return
	}
}
